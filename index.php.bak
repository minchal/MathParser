<?php

abstract class Token {
	public abstract function getValue();
	public abstract function toString();
	
	public function __toString() {
		return $this -> toString();
	}
}

abstract class OpToken extends Token {
	
	protected $left;
	protected $right;
	
	public function setLeft(Token $t) {
		$this -> left = $t;
	}
	
	public function setRight(Token $t) {
		$this -> right = $t;
	}
}


class ValToken extends Token {
	protected $num;
	public function setValue($num) {
		$this -> num = (float) $num;
	}
	
	public function getValue() {
		return $this->num;
	}
	
	public function toString() {
		return (string) $this -> num;
	}
}

class AddToken extends OpToken {
	public function getValue() {
		return $this->left->getValue() + $this->right->getValue();
	}
	
	public function toString() {
		return '(' . $this->left . '+' . $this->right . ')';
	}
}

class MultiToken extends OpToken {
	public function getValue() {
		return $this->left->getValue() * $this->right->getValue();
	}
	
	public function toString() {
		return '(' . $this->left . '*' . $this->right . ')';
	}
}

class Tokenizer {
	
	protected $str;
	protected $root;
	
	public function __construct($str) {
		$this -> str = $str;
	}
	
	public function prepare() {
		$this -> root = self::tokenize($this -> str);
	}
	
	public function getValue() {
		if (!$this -> root) {
			$this -> prepare();
		}
		
		return $this -> root -> getValue();
	}
	
	protected static function tokenize($str) {
		$str = self::clearString($str);
		
		if (!self::isValid($str)) {
			throw new Exception('Podany ciąg jest nieprawidłowy!');
		}
		
		$parts = self::explode($str, array('+','*','(',')'));
		
		return self::makeToken($parts);
	}
	
	protected static function makeToken($parts) {
		if (!$parts) {
			throw new Exception('Coś nie tak. Przekazano pusty ciąg albo nawias?');
		}
		
		// wyszukanie i zastąpienie nawiasów
		$next = array();
		
		for ($i=0; $i<count($parts); $i++) {
			$part = $parts[$i];
			
			if ($part == '(') {
				$tmp = array();
				
				$stack = 0;
				
				while ($i<count($parts)) {
					$i++;
					
					if ($parts[$i] == '(') {
						$stack++;
					}
					if ($parts[$i] == ')') {
						if ($stack==0) {
							break;
						}
						$stack--;
					}
					
					$tmp[] = $parts[$i];
				}
				
				// doszedł do końca
				if ($i == count($parts)) {
					throw new Exception('Nieprawidłowa ilość nawiasów zamykających!');
				}
				
				$token = self::makeToken($tmp);
				
				$next[] = $token;
			} else {
				$next[] = $part;
			}
		}
		
		$parts = $next;
		
		// wyszukanie i zastąpienie mnożeń
		while (($key = array_search('*', $parts)) !== false) {
			$token = new MultiToken();
			
			if (!isset($parts[$key-1])) {
				throw new Exception('Brak lewego argumentu dla mnożenia.');
			}
			
			$token -> setLeft(self::partToToken($parts[$key-1]));
			
			if (!isset($parts[$key+1])) {
				throw new Exception('Brak prawego argumentu dla mnożenia.');
			}
			
			$token -> setRight(self::partToToken($parts[$key+1]));
			
			unset($parts[$key-1]);
			unset($parts[$key+1]);
			$parts[$key] = $token;
			
			// uporządkowanie kluczy
			$parts = array_values($parts);
		}
		
		//print_r($parts);
		
		// wyszukanie i zastąpienie sum
		while (($key = array_search('+', $parts)) !== false) {
			$token = new AddToken();
			
			if (!isset($parts[$key-1])) {
				throw new Exception('Brak lewego argumentu dla sumy.');
			}
			
			$token -> setLeft(self::partToToken($parts[$key-1]));
			
			if (!isset($parts[$key+1])) {
				throw new Exception('Brak prawego argumentu dla sumy.');
			}
			
			$token -> setRight(self::partToToken($parts[$key+1]));
			
			unset($parts[$key-1]);
			unset($parts[$key+1]);
			$parts[$key] = $token;
			
			// uporządkowanie kluczy
			$parts = array_values($parts);
		}
		
		//print_r($parts);
		
		if (count($parts) > 1) {
			throw new Exception('Coś poszło całkiem nie tak :/');
		}
		
		return self::partToToken($parts[0]);
	}
	
	protected static function partToToken($part) {
		if ($part instanceof Token) {
			return $part;
		}
		
		if (is_numeric($part)) {
			$r = new ValToken();
			$r -> setValue($part);
			return $r;
		}
		
		throw new Exception('Coś nie tak. Dwa znaki obok siebie?');
	}
	
	protected static function explode($str, $ops) {
		$ret = array();
		
		$len = strlen($str);
		
		$buff = '';
		
		for ($i=0; $i < $len; $i++) {
			$char = $str[$i];
			
			if (in_array($char, $ops)) {
				if ($buff) {
					$ret[] = $buff;
					$buff = '';
				}
				
				$ret[] = $char;
				
			} else {
				$buff .= $char;
			}
		}
		
		if ($buff) {
			$ret[] = $buff;
		}
		
		return $ret;
	}
	
	protected static function clearString($str) {
		return str_replace(' ', '',  str_replace(',', '.', $str));
	}
	
	protected static function isValid($str) {
		return true; // TODO
	}
	
	public static function printValue($str) {
		try {
			eval('$r='.$str.';');
			echo 'Input: '.$str .'='.$r ."\n";
			$t = new Tokenizer($str);
			
			echo 'Output: '.$t -> getValue() ."\n";
			echo 'As string: '.$t -> root -> toString() ."\n";
		} catch (Exception $e) {
			echo $e -> getMessage() ."\n";
		}
	}
}

//----------------------------------
echo '<pre>';

Tokenizer::printValue('2+(2.1+(10+11)*32+4)*5');

echo '<br /><hr /><br />';

Tokenizer::printValue('222.1');
echo '<br /><hr /><br />';

Tokenizer::printValue('2+2*2');

echo '<br /><hr /><br />';

Tokenizer::printValue('1+2+3');

echo '<br /><hr /><br />';

Tokenizer::printValue('1*2*3');

echo '<br /><hr /><br />';

Tokenizer::printValue('(2+2)*(3+3)');



/*$a = new MultiToken();

$b = new AddToken();
	$b1 = new ValToken();
		$b1 -> setValue(2);
	$b2 = new AddToken();
		$b21 = new ValToken();
			$b21 -> setValue(3);
		$b22 = new ValToken();
			$b22 -> setValue(4);
		
		$b2 -> setLeft($b21);
		$b2 -> setRight($b22);
	
	$b -> setLeft($b1);
	$b -> setRight($b2);


$c = new ValToken();
	$c -> setValue(5);

$a -> setLeft($b);
$a -> setRight($c);

var_dump($a);
var_dump($a -> getValue());
var_dump($a -> toString());*/
